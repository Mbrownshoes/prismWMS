<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="main.css"> 

    <style>
    @import url(//cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.2/leaflet.css);

    #map {
        width: 760px;
        height: 500px;
        background: #fff;
    }
    svg {
        position: relative;
    }

    .canada {

        stroke: #fff;
        stroke-width: 1px;
    }



.us{
    fill: #bdbdbd;
    stroke: #fff;
    stroke-width: 1px;
}


.axis .domain {
    fill: none;
    stroke: #000;
    stroke-opacity: .3;
    stroke-width: 10px;
    stroke-linecap: round;

}
.tick line {
    stroke: #aaa;
    shape-rendering: crispEdges;
}



.axis .halo {
    fill: none;
    stroke: #fff;
    stroke-width: 8px;
    stroke-linecap: round;
}

.g-slider {
    fill: white;
}

.g-slider .background {
    cursor: ew-resize !important;
}
.g-slider .handle {
    fill: #fff;
    stroke: #000;
    stroke-width: 1.0px;
    pointer-events: none;

}

#slider {
    position: absolute;
    left: 20px;
    top: 330px;
    font-size: 0.8em;
}


.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.axisC path,
.axisC line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.x.axisC path {
  display: none;
}
#chart {
  font: 10px sans-serif;
  
}

#chart_container {
    position: absolute;
    left:760px;
    top:110px;

}


</style>



<body>
 <h1>British Columbia High-Resolution PRISM Climatology</h1>

 <p>Click on the map to see monthly values for that location</p>   

<p id="map">

<div id="chart_container">
    <div id="y_axis"></div>
    <div id="chart"></div>
</div>

<div id="slider"></div>

<!-- <select class="climate_var">
    <option value="Tmax">Maximum Temperature </option>
    <option value="Tmin">Minimum Temperature </option>
    <option value="pr">Precipitation </option>
</select> -->

<script type="text/javascript" src="http://tools.pacificclimate.org/dataportal/js/proj4js-compressed.js"></script>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>
<script src="http://d3js.org/queue.v1.min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.2/leaflet.js"></script>
<script src="proj4-compressed.js"></script>
<script src="src/proj4leaflet.js"></script>
<script src="src/L.TileLayer.BetterWMS.js"></script>

<script type='text/javascript' src="http://cdnjs.cloudflare.com/ajax/libs/jquery-ajaxtransport-xdomainrequest/1.0.1/jquery.xdomainrequest.min.js"></script>

<script>
var width = 760,
    height = 500;

var crs = new L.Proj.CRS('EPSG:3005',
        '+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs', {
            resolutions: [
                4592, 3000, 1648, 1024, 512, 256, 128,
                64, 32, 16, 8, 4, 2, 1, 0.5
            ],
            origin: [0, 0]
        }),
    southWest = L.latLng(46.851760, -142.734375),
    northEast = L.latLng(60.364901, -114.917969),
    bounds = L.latLngBounds(southWest, northEast);

map = new L.Map('map', {
    crs: crs,
    continuousWorld: true,
    worldCopyJump: false,
    maxBounds: bounds
});

// precip layer
// 'pr_monClim_PRISM_historical_run1_197101-200012/pr',
// styles: 'boxfill/occam_inv',
// logscale: false,


map.setView([54, -122.9364], 1);


queue()
    .defer(d3.json, "canada.json")
    .defer(d3.json, "us.json")
    .defer(d3.json, "ocean.json")
    .await(ready);


function ready(error, canada, us, ocean) {

    var sliderWidth = 200,
        sliderHeight = 30;

    var margin = {
        top: 10,
        right: 10,
        bottom: 10,
        left: 10
    }

    var current = {
            "month": 1
        },
        maxValue = 12,
        moving;

    var colors = d3.scale.quantize()
        .range(["rgb(69,117,180)", "rgb(116,173,209)", "rgb(171,217,233)", "rgb(224,243,248)", "rgb(255,255,178)", "rgb(254,217,118)", "rgb(254,178,76)", "rgb(253,141,60)", "rgb(252,78,42)", "rgb(227,26,28)", "rgb(177,0,38)"]);

    var legend_labels = ["-20", "-15", "-10", "-5", "0", "5", "10", "15", "20", "25", "30"]


    var sliderContainer = d3.select("#slider").append("svg")
        .attr("width", sliderWidth + margin.left + margin.right + 10)
        .attr("height", sliderHeight + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + (margin.top)+ ")");

    var x = d3.scale.linear()
        .domain([1, 12])
        .range([0, sliderWidth])
        .clamp(true);

    var brushToMonth = d3.scale.quantile()
        .domain([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])
        .range([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);

    var brush = d3.svg.brush()
        .x(x)
        .extent([current.month, current.month])
        .on("brush", brushed);

    var xTicks = {
        "1": "Jan",
        "2": "",
        "3": "Mar",
        "4": "",
        "5": "May",
        "6": "",
        "7": "Jul",
        "8": "",
        "9": "Sep",
        "10": "",
        "11": "Nov",
        "12": ""
    };

    var xAxis = d3.svg.axis()
        .scale(x)
        .orient("button")
        .ticks(12)
        .tickFormat(function(d) {
            return xTicks[d];
        })
        .tickSize(10, 0)
        .tickPadding(0);

    var svg = d3.select(map.getPanes().overlayPane).append("svg"),
        g = svg.append("g").attr("class", "leaflet-zoom-hide");



    var pacific = topojson.feature(ocean, ocean.objects.ocean);


    // first variable is used to center and scale map the viewport
    var bTopo = topojson.feature(canada, canada.objects.canada),
        topo = bTopo.features;
    feature = topo;

    svg.selectAll("path")
        .data(topo)
        .enter()
        .append("path");


    var transform = d3.geo.transform({
            point: projectPoint
        }),
        path = d3.geo.path().projection(transform);

    var feature = g.selectAll("path")
        .data(bTopo.features)
        .enter()
        .append("path")
        .attr("class", "canada")
        .attr("id", "land");


    map.on("viewreset", reset);


    var feature1 = g.selectAll("path1")
        .data(us.features)
        .enter().append("path")
        .attr("class", "us");

    var ocean = g.selectAll("path2") // only using to mask tiles that spill over boarder. Could clip tiles instead...
        .data(pacific.features)
        .enter().append("path")
        .attr("class", "ocean");


    drawMap(1) //initialize with Jan for now

    sliderContainer.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + sliderHeight / 2 + ")")
        .call(d3.svg.axis()
            .scale(x)
            .orient("button")
            .ticks(12)
            .tickFormat(function(d) {
                return xTicks[d];
            })
            .tickSize(0)
            .tickPadding(12))
        .select(".domain")
        .select(function() {
            return this.parentNode.appendChild(this.cloneNode(true));
        })
        .attr("class", "halo");

    sliderContainer.call(xAxis)

    var slider = sliderContainer.append("g")
        .attr("class", "g-slider")
        .call(brush);

    slider.selectAll(".extent, .resize").remove();

    slider.select(".background")
        .attr("height", sliderHeight);

    var handle = slider.append("circle")
        .attr("class", "handle")
        .attr("transform", "translate(0," + sliderHeight / 2 + ")")
        .attr("r", 9);


    var legend = g.selectAll('g.legendEntry')
            .data(colors.range().reverse())
            .enter()
            .append("g")
            .attr("class",'legend');

    reset();

    function reset() {

        var bounds = path.bounds(us), //Use US for the projection bounds
            topLeft = bounds[0],
            bottomRight = bounds[1];

        svg.attr("width", bottomRight[0] - topLeft[0])
            .attr("height", bottomRight[1] - topLeft[1])
            .style("left", topLeft[0] + "px")
            .style("top", topLeft[1] + "px");

        g.attr("transform", "translate(" + -topLeft[0] + "," + -topLeft[1] + ")");

        feature.attr("d", path)
            .style("fill", function(d) {
                // console.log(d)
                if (d.properties.province == "British Columbia") {
                    return "none"
                } else {
                    return "#ddd";
                }
            });


        feature1.attr("d", path)
            .style("fill", "#ddd");
        ocean.attr("d", path)
            .style("fill", "#a6cef5");



    }

    function projectPoint(x, y) {
        var point = map.latLngToLayerPoint(new L.LatLng(y, x));
        this.stream.point(point.x, point.y);
    };


    var wmsL,
        relief;

    // $(document).ready(function(){
    //     $('.climate_var').on('change',function(){
    //         climate_var = $('.climate_var').val();
    //         document.getElementById("title").innerHTML = $('.climate_var').val();
    //         console.log(climate_var)

    function drawMap(date) {

        // use custom tiles. Comment out to use PCIC tile
        var imageUrl = 'http://pbrown.ca:8080/geoserver/cite/wms?service=WMS&version=1.1.0&request=GetMap&layers=cite:tmax'+date+'&styles=&bbox=-41480.026427602745,330578.24608669477,1968950.324334159,1962724.6619271105&width=512&height=415&srs=EPSG:3153&format=image%2Fpng',
            imageBounds = [[61.5, -113.05], [47.1, -146]];

        relief = L.imageOverlay(imageUrl, imageBounds)
        relief.addTo(map).bringToBack();

  
        wmsL = L.tileLayer.betterWms("http://prism.noip.me:82/ncWMS/wms", {
            layers: 'tmax_monClim_PRISM_historical_run1_197101-200012/tmax',
            format: 'image/png',
            maxZoom: 14,
            minZoom: 0,
            transparent: 'true',
            month: date,
            time: '1985-' + date + '-15',
            styles: 'boxfill/rainbow',
            logscale: false,
            numcolorbands: 254,
            version: '1.1.1',
            continuousWorld: true,
            opacity: 0 // change to 1 to make visible
        });
        console.log(wmsL)

        wmsL.addTo(map)
        // var mywms = L.tileLayer.wms("http://pbrown.ca:8080/geoserver/cite/wms", {
        // layers: 'cite:band1',
        //     format: 'image/png',
        //     transparent: true,
        //     version: '1.1.0',
        //     attribution: "myattribution"
        // });
        // mywms.addTo(map);
    };

    // legend 
    var ls_w = 20;
    legend
        .append("rect")
        .attr("y", 450)
        .attr("x", function(d, i) {
            // console.log(d)
            return (width ) - (i * ls_w) - 2*ls_w;
        })
        .attr("width", ls_w)
        .attr("height", 10)
        .style("fill", function(d) {
            return d;
        });

    legend.append("text")
        .attr("y", 475)
        .attr("x", function(d, i) {
            return (width) - (i * ls_w) - ls_w - 10;
        })
        .attr("class", "leg")
        .text(function(d,i) {

            if (i === 0)
                return legend_labels[colors.range().length - i-1] + "\xB0 C";
            else
                return legend_labels[colors.range().length - i-1];
        });

    function brushed() {

        var value = brush.extent()[0];

        if (d3.event.sourceEvent) {

            value = Math.round(x.invert(d3.mouse(this)[0]));

            brush.extent([value, value]);
        }
        handle.attr("cx", x(value));
        var brushDate = brushToMonth(value - 1);

        current.month = brushDate;
        map.removeLayer(wmsL) // remove player to prevent them from piling up.
        map.removeLayer(relief)
        drawMap(brushDate)

    }

}


//setup graph but don't show yet.

var counter = 0;


var chartData = [];

for (i = 1; i < 0; i++) {
    chartData.push({
        x: '1985-' + i + '-15',
        y: i
    })
}

// make graph here (move later)

var margin = {
        top: 20,
        right: 20,
        bottom: 30,
        left: 50
    },
    widthG = 760 / 2 - margin.left - margin.right,
    heightG = 250 - margin.top - margin.bottom;

var parseDate = d3.time.format("%Y-%m-%d").parse;

chartData.forEach(function(d) {
    d.x = parseDate(d.x);
});

var x = d3.time.scale()
    .range([0, widthG]);

var y = d3.scale.linear()
    .range([heightG, 0]);

var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom")
    .tickFormat(d3.time.format("%b"));

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");

var line = d3.svg.line()
    .interpolate("basis")
    .x(function(d) {
        return x(d.x);
    })
    .y(function(d) {
        return y(d.y);
    });

var svg = d3.select("#chart").append("svg")
    .attr("width", widthG + margin.left + margin.right)
    .attr("height", heightG + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


x.domain(d3.extent(chartData, function(d) {
    return d.x;
}));
y.domain([-20, 30]);

svg.append("g") //x axis group
    .attr("class", "x axisC")
    .attr("transform", "translate(0," + heightG + ")")
    .call(xAxis);

// svg.append("g")
//     .attr("class", "y axisC")
//     .call(yAxis)
//   .append("text")
//     .attr("transform", "rotate(-90)")
//     .attr("y", 6)
//     .attr("dy", ".71em")
//     .style("text-anchor", "end")
//     .text("Temperature \xB0 C");

svg.append("path")
    .attr("class", "line")
    .attr("d", line(chartData));

svg.selectAll("circle")
    .data(chartData)
    .enter()
    .append("circle")
    .attr("r", 3.5)
    .attr("cx", function(d) {
        return x(d.x);
    })
    .attr("cy", function(d) {
        return y(d.y);
    })
    .style("fill", "rgb(214,39,40)");
</script>





</body>
</html>
